



MASQUE                                                       D. Schinazi
Internet-Draft                                                Google LLC
Intended status: Standards Track                             6 July 2024
Expires: 7 January 2025


               DNS Configuration for Proxying IP in HTTP
              draft-schinazi-masque-connect-ip-dns-latest

Abstract

   Proxying IP in HTTP allows building a VPN through HTTP load
   balancers.  However, at the time of writing, that mechanism doesn't
   offer a mechanism for communicating DNS configuration information
   inline.  In contrast, most existing VPN protocols provide a mechanism
   to exchange DNS configuration information.  This document describes
   an extension that exchanges this information using HTTP capsules.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://DavidSchinazi.github.io/draft-schinazi-masque-connect-ip-dns/
   draft-schinazi-masque-connect-ip-dns.html.  Status information for
   this document may be found at https://datatracker.ietf.org/doc/draft-
   schinazi-masque-connect-ip-dns/.

   Discussion of this document takes place on the Multiplexed
   Application Substrate over QUIC Encryption Working Group mailing list
   (mailto:masque@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/masque/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/masque/.

   Source for this draft and an issue tracker can be found at
   https://github.com/DavidSchinazi/draft-schinazi-masque-connect-ip-
   dns.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 7 January 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Conventions and Definitions
   2.  Mechanism
     2.1.  DNS_REQUEST Capsule
     2.2.  DNS_ASSIGN Capsule
   3.  Handling
   4.  Examples
     4.1.  Full-Tunnel Consumer VPN
     4.2.  Split-Tunnel Enterprise VPN
   5.  Security Considerations
   6.  IANA Considerations
   7.  References
     7.1.  Normative References
     7.2.  Informative References
   Acknowledgments
   Author's Address

1.  Introduction

   Proxying IP in HTTP ([CONNECT-IP]) allows building a VPN through HTTP
   load balancers.  However, at the time of writing, that mechanism
   doesn't offer a mechanism for communicating DNS configuration
   information inline.  In contrast, most existing VPN protocols provide
   a mechanism to exchange DNS configuration information (e.g.,
   [IKEv2]).  This document describes an extension that exchanges this
   information using HTTP capsules ([HTTP-DGRAM]).  This document does
   not define any new ways to convey DNS queries or responses, only a
   mechanism to exchange DNS configuration information.

1.1.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   This document uses terminology from [QUIC].  Where this document
   defines protocol types, the definition format uses the notation from
   Section 1.3 of [QUIC].  This specification uses the variable-length
   integer encoding from Section 16 of [QUIC].  Variable-length integer
   values do not need to be encoded in the minimum number of bytes
   necessary.

2.  Mechanism

   Similar to how Proxying IP in HTTP exchanges IP address configuration
   information (Section 4.7 of [CONNECT-IP]), this mechanism leverages
   capsules to request DNS configuration information and to assign it.
   Similarly, this mechanism is bidirectional: either endpoint can
   request DNS configuration information by sending a DNS_REQUEST
   capsule, and either endpoint can send DNS configuration information
   in a DNS_ASSIGN capsule.  These capsules follow the format defined
   below.

   Nameserver {
     Type (i),
     Length (i),
     Value (...),
   }

                        Figure 1: Nameserver Format

   Each Nameserver structure contains the following fields:

   Type:  An integer representing the protocol over which DNS queries
      and responses are sent.  See below for possible values.  Encoded
      as a variable-length integer.

   Length:  The length of the following Value field, encoded as a
      variable-length integer.

   Value:  DNS name server configuration value, depends on the Type.
      This is commonly an IP address, but for other protocols it can
      also represent a URI template or a hostname.

   This document defines the following types:

   *  DNS over port 53.  Type = 0.  DNS is sent unencrypted over UDP or
      TCP port 53, as per [DNS].  The Value is an IP address (either
      IPv4 or IPv6) encoded in network byte order.  Length SHALL be
      either 32 or 128 bits.

   *  DNS over TLS.  Type = 1.  DNS is sent over TLS, as per [DoT].  The
      Value is a hostname, optionally followed by a colon and a port.
      The encoding is the same as an authority without userinfo as
      defined in Section 3.2 of [URI].  It is encoded as ASCII, and not
      null-terminated.  IPv4 and IPv6 addresses can be encoded using
      this format, though IPv6 addresses need to be enclosed in square
      brackets.

   *  DNS over QUIC.  Type = 2.  DNS is sent over QUIC, as per [DoQ].
      The Value is a hostname, encoded the same as for DNS over TLS.

   *  DNS over HTTPS.  Type = 3.  DNS is sent over HTTPS, as per [DoH].
      The Value is a URI Template.  It is encoded as ASCII, and not
      null-terminated.

   *  TODO: properly define an IANA registry with GREASE for future
      types.

   Domain {
     Domain Length (i),
     Domain Name (..),
   }

                      Figure 2: Internal Domain Format

   Each Domain contains the following fields:

   Domain Length:  Length of the following Domain field, encoded as a
      variable-length integer.

   Domain Name:  Fully Qualified Domain Name in DNS presentation format
      and using an Internationalized Domain Names for Applications
      (IDNA) A-label ([IDNA]).

   DNS Configuration {
     Request ID (i),
     Nameserver Count (i),
     Nameserver (..) ...,
     Internal Domain Count (i),
     Internal Domain (..) ...,
     Search Domain Count (i),
     Search Domain (..) ...,
   }

                     Figure 3: Assigned Address Format

   Each DNS Configuration contains the following fields:

   Request ID:
      Request identifier, encoded as a variable-length integer.  If this
      DNS Configuration is part of a request, then this contains a
      unique request identifier.  If this DNS configuration is part of
      an assignment that is in response to a DNS configuration request
      then this field SHALL contain the value of the corresponding field
      in the request.  If this DNS configuration is part of an
      unsolicited assignment, this field SHALL be zero.

   Nameserver Count:
      The number of Nameserver structures following this field.  Encoded
      as a variable-length integer.

   Nameserver:
      A series of Nameserver structures representing DNS name servers.

   Internal Domain Count:
      The number of Domain structures following this field.  Encoded as
      a variable-length integer.

   Internal Domain:
      A series of Domain structures representing internal DNS names.

   Search Domain Count:
      The number of Domain structures following this field.  Encoded as
      a variable-length integer.

   Search Domain:
      A series of Domain structures representing search domains.

2.1.  DNS_REQUEST Capsule

   The DNS_REQUEST capsule (see Section 6 for the value of the capsule
   type) allows an endpoint to request DNS configuration from its peer.
   The capsule allows the endpoint to optionally indicate a preference
   for which DNS configuration it would get assigned.  The sender can
   indicate that it has no preference by not sending any name servers or
   domain names in its request DNS Configuration.

   DNS_REQUEST Capsule {
     Type (i) = DNS_REQUEST,
     Length (i),
     DNS Configuration (..),
   }

                    Figure 4: DNS_REQUEST Capsule Format

   When sending a DNS_REQUEST capsule, the sender MUST generate and send
   a new non-zero request ID that was not previously used on this IP
   Proxying stream.  Note that this request ID namespace is distinct
   from the one used by ADDRESS_ASSIGN capsules (see Section 4.7.1 of
   [CONNECT-IP]).

   An endpoint that receives a DNS_REQUEST capsule SHALL reply by
   sending a DNS_ASSIGN capsule with the corresponding request ID.  That
   DNS_ASSIGN capsule MAY be empty, that indicates that its sender has
   no DNS configuration to share with its peer.

2.2.  DNS_ASSIGN Capsule

   The DNS_ASSIGN capsule (see Section 6 for the value of the capsule
   type) allows an endpoint to send DNS configuration to its peer.

   DNS_ASSIGN Capsule {
     Type (i) = DNS_ASSIGN,
     Length (i),
     DNS Configuration (..),
   }

                    Figure 5: DNS_ASSIGN Capsule Format

   When sending a DNS_ASSIGN capsule in response to a received
   DNS_REQUEST capsule, the Request ID field in the DNS_ASSIGN capsule
   SHALL be set to the value in the received DNS_REQUEST capsule.
   Otherwise the request ID MUST be set to zero.

3.  Handling

   Note that internal domains include subdomains.  In other words, if
   the DNS configuration contains a domain, that indicates that the
   corresponding domain and all of its subdomains can be resolved by the
   name servers exchanged in the same DNS configuration.  Sending an
   empty string as an internal domain indicates the DNS root; i.e., that
   the corresponding name server can resolve all domain names.

   As with other IP Proxying capsules, the receiver can decide whether
   to use or ignore the configuration information.  For example, in the
   consumer VPN scenario, clients will trust the server and apply
   received DNS configuration, whereas servers will ignore any DNS
   configuration sent by the client.

   If the IP proxy sends a DNS_ASSIGN capsule containing a DNS over
   HTTPS name server, then the client can validate whether the IP proxy
   is authoritative for the hostname in the URI template.  If this
   validation succeeds, the client SHOULD send its DNS queries to that
   name server directly as independent HTTPS requests over the same
   HTTPS connection.

4.  Examples

4.1.  Full-Tunnel Consumer VPN

   A full-tunnel consumer VPN hosted at masque.example could configure
   the client to use DNS over HTTPS to the IP proxy itself by sending
   the following configuration.

   DNS Configuration = {
     Nameservers = [{
       Type = 3,  // DNS over HTTPS
       Value = "https://masque.example/dns-query{?dns}",
     }],
     Internal Domains = [""],
     Search Domains = [],
   }

                       Figure 6: Full Tunnel Example

4.2.  Split-Tunnel Enterprise VPN

   An enterprise switching their preexisting IPsec split-tunnel VPN
   could use the following configuration.

   DNS Configuration = {
     Nameservers = [{
       Type = 0,  // DNS over 53
       Value = 2001:db8::1,
     }, {
       Type = 0,  // DNS over 53
       Value = 192.0.2.33,
     }],
     Internal Domains = ["internal.corp.example"],
     Search Domains = [
       "internal.corp.example",
       "corp.example",
     ],
   }

                       Figure 7: Split Tunnel Example

5.  Security Considerations

   Acting on received DNS_ASSIGN capsules can have significant impact on
   endpoint security.  Endpoints MUST ignore DNS_ASSIGN capsules unless
   it has reason to trust its peer and is expecting DNS configuration
   from it.

   The requirement for an endpoint to always send DNS_ASSIGN capsules in
   response to DNS_REQUEST capsules could lead it to buffer unbounded
   amounts of memory if the underlying stream is blocked by flow or
   congestion control.  Implementations MUST place an upper bound on
   that buffering and abort the stream if that limit is reached.

6.  IANA Considerations

   This document, if approved, will request IANA add the following
   values to the "HTTP Capsule Types" registry maintained at
   <https://www.iana.org/assignments/masque>.

                       +============+==============+
                       | Value      | Capsule Type |
                       +============+==============+
                       | 0x1460B736 | DNS_ASSIGN   |
                       +------------+--------------+
                       | 0x1460B737 | DNS_REQUEST  |
                       +------------+--------------+

                           Table 1: New Capsules

   Note that, if this document is approved, the values defined above
   will be replaced by smaller ones before publication.

   All of these new entries use the following values for these fields:

   Status:  provisional (permanent if this document is approved)
   Reference:  This document
   Change Controller:  IETF
   Contact:  masque@ietf.org
   Notes:  None

7.  References

7.1.  Normative References

   [CONNECT-IP]
              Pauly, T., Ed., Schinazi, D., Chernyakhovsky, A.,
              Kühlewind, M., and M. Westerlund, "Proxying IP in HTTP",
              RFC 9484, DOI 10.17487/RFC9484, October 2023,
              <https://www.rfc-editor.org/rfc/rfc9484>.

   [DNS]      Mockapetris, P., "Domain names - implementation and
              specification", STD 13, RFC 1035, DOI 10.17487/RFC1035,
              November 1987, <https://www.rfc-editor.org/rfc/rfc1035>.

   [DoH]      Hoffman, P. and P. McManus, "DNS Queries over HTTPS
              (DoH)", RFC 8484, DOI 10.17487/RFC8484, October 2018,
              <https://www.rfc-editor.org/rfc/rfc8484>.

   [DoQ]      Huitema, C., Dickinson, S., and A. Mankin, "DNS over
              Dedicated QUIC Connections", RFC 9250,
              DOI 10.17487/RFC9250, May 2022,
              <https://www.rfc-editor.org/rfc/rfc9250>.

   [DoT]      Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, "Specification for DNS over Transport
              Layer Security (TLS)", RFC 7858, DOI 10.17487/RFC7858, May
              2016, <https://www.rfc-editor.org/rfc/rfc7858>.

   [HTTP-DGRAM]
              Schinazi, D. and L. Pardue, "HTTP Datagrams and the
              Capsule Protocol", RFC 9297, DOI 10.17487/RFC9297, August
              2022, <https://www.rfc-editor.org/rfc/rfc9297>.

   [IDNA]     Klensin, J., "Internationalized Domain Names for
              Applications (IDNA): Definitions and Document Framework",
              RFC 5890, DOI 10.17487/RFC5890, August 2010,
              <https://www.rfc-editor.org/rfc/rfc5890>.

   [QUIC]     Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/rfc/rfc9000>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [URI]      Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/rfc/rfc3986>.

7.2.  Informative References

   [IKEv2]    Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <https://www.rfc-editor.org/rfc/rfc7296>.

   [IKEv2-DNS]
              Pauly, T. and P. Wouters, "Split DNS Configuration for the
              Internet Key Exchange Protocol Version 2 (IKEv2)",
              RFC 8598, DOI 10.17487/RFC8598, May 2019,
              <https://www.rfc-editor.org/rfc/rfc8598>.

Acknowledgments

   The mechanism is this document was inspired by [IKEv2] and
   [IKEv2-DNS].

Author's Address

   David Schinazi
   Google LLC
   1600 Amphitheatre Parkway
   Mountain View, CA 94043
   United States of America
   Email: dschinazi.ietf@gmail.com
